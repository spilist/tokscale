/* auto-generated by NAPI-RS */
/* eslint-disable */
/** Daily contribution data */
export interface DailyContribution {
  date: string
  totals: DailyTotals
  intensity: number
  tokenBreakdown: TokenBreakdown
  sources: Array<SourceContribution>
}

/** Daily contribution totals */
export interface DailyTotals {
  tokens: number
  cost: number
  messages: number
}

/** Data summary statistics */
export interface DataSummary {
  totalTokens: number
  totalCost: number
  totalDays: number
  activeDays: number
  averagePerDay: number
  maxCostInSingleDay: number
  sources: Array<string>
  models: Array<string>
}

/** Finalize graph */
export declare function finalizeGraph(options: FinalizeGraphOptions): Promise<GraphResult>

/** Options for finalizing graph */
export interface FinalizeGraphOptions {
  homeDir?: string
  localMessages: ParsedMessages
  includeCursor: boolean
  since?: string
  until?: string
  year?: string
}

/** Options for finalizing monthly report */
export interface FinalizeMonthlyOptions {
  homeDir?: string
  localMessages: ParsedMessages
  includeCursor: boolean
  since?: string
  until?: string
  year?: string
}

/** Finalize monthly report */
export declare function finalizeMonthlyReport(options: FinalizeMonthlyOptions): Promise<MonthlyReport>

/** Finalize model report: apply pricing to local messages, add Cursor, aggregate */
export declare function finalizeReport(options: FinalizeReportOptions): Promise<ModelReport>

/**
 * Finalize both report and graph in a single call with shared pricing
 * This ensures consistent costs between report and graph data
 */
export declare function finalizeReportAndGraph(options: FinalizeReportOptions): Promise<ReportAndGraph>

/** Options for finalizing report */
export interface FinalizeReportOptions {
  homeDir?: string
  localMessages: ParsedMessages
  includeCursor: boolean
  since?: string
  until?: string
  year?: string
}

/** Generate graph data with pricing calculation */
export declare function generateGraphWithPricing(options: ReportOptions): Promise<GraphResult>

/** Get model usage report with pricing calculation */
export declare function getModelReport(options: ReportOptions): Promise<ModelReport>

/** Get monthly usage report with pricing calculation */
export declare function getMonthlyReport(options: ReportOptions): Promise<MonthlyReport>

/** Metadata about the graph generation */
export interface GraphMeta {
  generatedAt: string
  version: string
  dateRangeStart: string
  dateRangeEnd: string
  processingTimeMs: number
}

/** Complete graph result */
export interface GraphResult {
  meta: GraphMeta
  summary: DataSummary
  years: Array<YearSummary>
  contributions: Array<DailyContribution>
}

/** Simple health check to verify the native module is working */
export declare function healthCheck(): string

/** Options for parsing local sources only (no Cursor) */
export interface LocalParseOptions {
  homeDir?: string
  sources?: Array<string>
  since?: string
  until?: string
  year?: string
}

export declare function lookupPricing(modelId: string, provider?: string | undefined | null): Promise<PricingLookupResult>

/** Model report result */
export interface ModelReport {
  entries: Array<ModelUsage>
  totalInput: number
  totalOutput: number
  totalCacheRead: number
  totalCacheWrite: number
  totalMessages: number
  totalCost: number
  processingTimeMs: number
}

/** Model usage summary for reports */
export interface ModelUsage {
  source: string
  model: string
  provider: string
  input: number
  output: number
  cacheRead: number
  cacheWrite: number
  reasoning: number
  messageCount: number
  cost: number
}

/** Monthly report result */
export interface MonthlyReport {
  entries: Array<MonthlyUsage>
  totalCost: number
  processingTimeMs: number
}

/** Monthly usage summary */
export interface MonthlyUsage {
  month: string
  models: Array<string>
  input: number
  output: number
  cacheRead: number
  cacheWrite: number
  messageCount: number
  cost: number
}

export interface NativePricing {
  inputCostPerToken: number
  outputCostPerToken: number
  cacheReadInputTokenCost?: number
  cacheCreationInputTokenCost?: number
}

export interface ParsedMessage {
  source: string
  modelId: string
  providerId: string
  sessionId: string
  timestamp: number
  date: string
  input: number
  output: number
  cacheRead: number
  cacheWrite: number
  reasoning: number
  agent?: string
}

/** Result of parsing local sources (excludes Cursor - it's network-synced) */
export interface ParsedMessages {
  messages: Array<ParsedMessage>
  opencodeCount: number
  claudeCount: number
  codexCount: number
  geminiCount: number
  ampCount: number
  droidCount: number
  processingTimeMs: number
}

/**
 * Parse local sources only (OpenCode, Claude, Codex, Gemini - NO Cursor)
 * This can run in parallel with network operations (Cursor sync, pricing fetch)
 */
export declare function parseLocalSources(options: LocalParseOptions): ParsedMessages

export interface PricingLookupResult {
  modelId: string
  matchedKey: string
  source: string
  pricing: NativePricing
}

/** Combined result for report and graph (single pricing lookup) */
export interface ReportAndGraph {
  report: ModelReport
  graph: GraphResult
}

/** Options for reports */
export interface ReportOptions {
  homeDir?: string
  sources?: Array<string>
  since?: string
  until?: string
  year?: string
}

/** Source contribution for a specific day */
export interface SourceContribution {
  source: string
  modelId: string
  providerId: string
  tokens: TokenBreakdown
  cost: number
  messages: number
}

/** Token breakdown by type */
export interface TokenBreakdown {
  input: number
  output: number
  cacheRead: number
  cacheWrite: number
  reasoning: number
}

/** Version of the native module */
export declare function version(): string

/** Year summary */
export interface YearSummary {
  year: string
  totalTokens: number
  totalCost: number
  rangeStart: string
  rangeEnd: string
}
